        // ========================================================================
        // NOTIFICATIONS METHODS
        // ========================================================================
        async checkNotifications(profileId) {
            if (this.checkingNotifications) {
                return;
            }
            
            this.checkingNotifications = true;
            this.showToast('info', 'Checking notifications...');
            
            try {
                const response = await axios.get(`/check_notifications/${profileId}`);
                
                if (response.data.status === 'success') {
                    this.$set(this.profileNotifications, profileId, response.data);
                    
                    const count = response.data.notification_count;
                    if (count > 0) {
                        this.showToast('success', `Found ${count} notification(s)!`);
                    } else {
                        this.showToast('info', 'No new notifications');
                    }
                } else {
                    this.showToast('warning', response.data.message || 'Could not check notifications');
                }
            } catch (error) {
                console.error('Error checking notifications:', error);
                this.showToast('error', 'Failed to check notifications');
            } finally {
                this.checkingNotifications = false;
            }
        },
        loadAllNotifications() {
            axios.get('/get_all_notifications')
                .then(response => {
                    if (response.data.status === 'success') {
                        response.data.notifications.forEach(notif => {
                            this.$set(this.profileNotifications, notif.profile_folder, notif);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error loading notifications:', error);
                });
        },

        // ========================================================================
        // DELETED LISTINGS METHODS
        // ========================================================================
        loadDeletedListings() {
            this.loadingDeleted = true;
            
            axios.get('/get_deleted_listings')
                .then(response => {
                    if (response.data.status === 'success') {
                        this.deletedListings = response.data.deleted_listings;
                        console.log(`âœ… Loaded ${this.deletedListings.length} deleted listings`);
                    } else {
                        this.showToast('error', 'Failed to load deleted listings');
                    }
                })
                .catch(error => {
                    console.error('âŒ Error loading deleted listings:', error);
                    const errorMessage = error.response?.data?.message || 'Failed to load deleted listings';
                    this.showToast('error', errorMessage);
                })
                .finally(() => {
                    this.loadingDeleted = false;
                });
        },
        async restoreListing(listingId) {
            const confirmed = await this.showDialog('confirm', 'Restore Listing', 
                'Restore this listing to active listings?', 'Restore');
            if (!confirmed) return;
            
            try {
                const response = await axios.post('/restore_listing', { id: listingId });
                
                if (response.data.status === 'success') {
                    this.showToast('success', 'Listing restored successfully!');
                    this.deletedListings = this.deletedListings.filter(l => l.id !== listingId);
                    this.loadListings();
                } else {
                    this.showToast('error', response.data.message || 'Failed to restore listing');
                }
            } catch (error) {
                console.error('Error restoring listing:', error);
                const errorMessage = error.response?.data?.message || 'Failed to restore listing';
                this.showToast('error', errorMessage);
            }
        },
        async permanentlyDeleteListing(listingId) {
            const confirmed = await this.showDialog('confirm', 'Permanently Delete', 
                'Are you sure? This action cannot be undone!', 'Delete Forever');
            if (!confirmed) return;
            
            const doubleConfirmed = await this.showDialog('confirm', 'Final Confirmation', 
                'This will PERMANENTLY delete the listing. Are you absolutely sure?', 'Yes, Delete Forever');
            if (!doubleConfirmed) return;
            
            try {
                const response = await axios.post('/permanently_delete_listing', { id: listingId });
                
                if (response.data.status === 'success') {
                    this.showToast('success', 'Listing permanently deleted');
                    this.deletedListings = this.deletedListings.filter(l => l.id !== listingId);
                } else {
                    this.showToast('error', response.data.message || 'Failed to permanently delete');
                }
            } catch (error) {
                console.error('Error permanently deleting listing:', error);
                const errorMessage = error.response?.data?.message || 'Failed to permanently delete listing';
                this.showToast('error', errorMessage);
            }
        },

        // ========================================================================
        // HELPER METHODS
        // ========================================================================
        formatDate(datetime) {
            if (!datetime) return 'N/A';
            try {
                // Parse datetime string manually to avoid timezone conversion
                // Input format: "2025-12-26T17:37:00" or "2025-12-26 17:37:00"
                const str = datetime.replace('T', ' ').split('.')[0];
                const parts = str.split(/[- :]/);

                // Validate we have at least year, month, day
                if (parts.length < 3) {
                    console.error('Invalid datetime format:', datetime);
                    return 'N/A';
                }

                // Create Date object: new Date(year, monthIndex, day, hours, minutes, seconds)
                const date = new Date(
                    parseInt(parts[0]),
                    parseInt(parts[1]) - 1,
                    parseInt(parts[2]),
                    parseInt(parts[3] || 0),
                    parseInt(parts[4] || 0),
                    parseInt(parts[5] || 0)
                );

                // Check if date is valid
                if (isNaN(date.getTime())) {
                    console.error('Invalid date created from:', datetime);
                    return 'N/A';
                }

                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
            } catch (e) {
                console.error('Error formatting date:', datetime, e);
                return 'N/A';
            }
        },
        formatTime(datetime) {
            if (!datetime) return 'N/A';
            try {
                // Parse datetime string manually to avoid timezone conversion
                const str = datetime.replace('T', ' ').split('.')[0];
                const parts = str.split(/[- :]/);

                // Validate we have at least year, month, day
                if (parts.length < 3) {
                    console.error('Invalid datetime format:', datetime);
                    return 'N/A';
                }

                // Create Date object: new Date(year, monthIndex, day, hours, minutes, seconds)
                const date = new Date(
                    parseInt(parts[0]),
                    parseInt(parts[1]) - 1,
                    parseInt(parts[2]),
                    parseInt(parts[3] || 0),
                    parseInt(parts[4] || 0),
                    parseInt(parts[5] || 0)
                );

                // Check if date is valid
                if (isNaN(date.getTime())) {
                    console.error('Invalid time created from:', datetime);
                    return 'N/A';
                }

                return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            } catch (e) {
                console.error('Error formatting time:', datetime, e);
                return 'N/A';
            }
        },
        formatDateTime(datetime) {
            if (!datetime) return 'N/A';
            try {
                const date = new Date(datetime);
                return date.toLocaleString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return 'N/A';
            }
        },
        formatNumber(num) {
            if (!num) return '0';
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        },
        formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }
    },

    mounted() {
        console.log('ðŸš€ FB Marketplace Bot Dashboard Loaded');
        
        // Load Edge profiles on startup
        this.loadProfiles();
        
        // Load initial data
        if (this.uploadHistory.length === 0) {
            this.loadUploadHistory();
        }
        
        // Load cached notifications
        this.loadAllNotifications();
        
        // Load deleted listings on startup
        this.loadDeletedListings();

        // Load scheduler status
        this.loadSchedulerStatus();

        // ========================================
        // BOT MANAGEMENT - LOAD CONFIG & CHECK STATUS
        // ========================================
        this.loadBotConfig();
        this.fetchBotStatus();
        
        // If bot is running, start polling
        setTimeout(() => {
            if (this.botStatus.process_running) {
                this.isRunning = true;
                this.startBotStatusPolling();
            }
        }, 1000);
    },
    
    beforeDestroy() {
        // Clean up polling interval
        this.stopBotStatusPolling();
    }
});
</script>
